<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: docs/v2.0.0/UsersGuide/dev/testAPI/user_guide.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.6.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('v2_80_80_2_users_guide_2dev_2test_a_p_i_2user__guide_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">docs/v2.0.0/UsersGuide/dev/testAPI/user_guide.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="v2_80_80_2_users_guide_2dev_2test_a_p_i_2user__guide_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# GDS Integration Test API User Guide</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;The GDS integration test API is a GDS Tool that provides useful functions and asserts for creating integration-level tests on an F Prime deployment. This document hopes to give an overview of the main features associated with the Test API and demonstrates common use patterns and highlight some anti-patterns. See [this link](markdown/contents.md) for the IntegrationTestAPI&#39;s sphinx-generated documentation.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;This integration test API was developed by Kevin Oran in the summer of 2019.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;## Quick Start</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;***</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;To work with the integration test API, the user must first create an instance of the StandardPipeline and then instantiate the API. This is boiler plate code that should be [moved inside the TestAPI](#moving-standardpipeline-to-api-constructor). The following code snippet accomplishes directing the GDS to a deployment dictionary, connecting to a running deployment, and finally instantiating the test API. This snippet **DOES NOT** run the GDS TCP Server or run an F Prime deployment. An example script to run the Ref App deployment without a GDS Tool can be found [here](../../../../Ref/scripts/run_ref_for_int_test.sh).</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;~~~~{.python}</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;from fprime_gds.common.pipeline.standard import StandardPipeline</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;from fprime_gds.common.utils.config_manager import ConfigManager</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;from fprime_gds.common.testing_fw.api import IntegrationTestAPI</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;from fprime_gds.common.testing_fw import predicates   # Recommended, but not required</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;# instantiate the GDS and connect to the Deployment</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;pipeline = StandardPipeline()</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;dict_path = &quot;/path/to/AppDictionary.xml&quot;  # user must replace with an actual path</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;pipeline.setup(ConfigManager(), dict_path)</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;pipeline.connect(&quot;127.0.0.1&quot;, 50000)  # user must replace with actual address and port</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;# instantiate Test API</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;log_path = &quot;/path/to/api/output/directory&quot;  # user must replace with an actual path</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;api = IntegrationTestAPI(pipeline, log_path)</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;# user can now use the Test API</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;api.assert_telemetry(&quot;SOME_CHANNEL_MNEMONIC&quot;)</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;~~~~</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;### How to use the API with a test framework</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;To use the test API with a testing framework like unittest or pytest there are four methods that should be called.</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;1. First, the test framework should call a **one-time** setup method to instantiate the API and connect to the deployment.</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;2. Second, the framework should call a setup method for each test case to call the API&#39;s start_test_case method that clears histories, and logs messages to denote test-case boundaries.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;3. Third, the framework should call any number of associated test cases.</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;4. Finally, the test framework should call a **one-time** teardown method to save the API at.</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;Below is an example of these steps using unittest. For an example of this using pytest, see the Ref App [integration tests](../../../../Ref/test/int/ref_integration_test.py).</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;~~~~{.python}</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;import unittest</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;from fprime_gds.common.pipeline.standard import StandardPipeline</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;from fprime_gds.common.utils.config_manager import ConfigManager</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;from fprime_gds.common.testing_fw.api import IntegrationTestAPI</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;from fprime_gds.common.testing_fw import predicates   # Recommended, but not required</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;class SomeTestCases(unittest.TestCase):</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    @classmethod</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    def setUpClass(cls):</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        # this is used to generate a case_id</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        cls.case_list = []</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        # instantiate the GDS and connect to the deployment</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        cls.pipeline = StandardPipeline()</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        dict_path = &quot;/path/to/AppDictionary.xml&quot;  # user must replace with an actual path</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        cls.pipeline.setup(ConfigManager(), dict_path)</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        cls.pipeline.connect(&quot;127.0.0.1&quot;, 50000)</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        # instantiate Test API</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        log_path = &quot;/path/to/api/output/directory&quot;  # user must replace with an actual path</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        cls.api = IntegrationTestAPI(cls.pipeline, log_path)</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    def setUp(self):</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        count = len(self.case_list)</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        self.api.start_test_case(self._testMethodName, count)</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        self.case_list.append(1)</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    @classmethod</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    def tearDownClass(cls):</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        cls.pipeline.disconnect()</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        cls.api.teardown()</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    def test_case_one(self):</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        self.api.test_assert(True, &quot;The user has successfully set up the API.&quot;)</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    def test_case_two(self):</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        self.api.test_assert(False, &quot;The user has successfully failed a test case.&quot;)</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;# used when this unit test were to be run as a python module</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;if __name__ == &quot;__main__&quot;:</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    unittest.main()</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;~~~~</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;## Usage Patterns</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;***</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;All usage patterns are written such that they would be compatible with the test framework example described above: each test case assumes that the histories were recently emptied and that the `self.api` field is a connected instance of the integration test API. For simplicity, usage examples will rely on mock flight software dictionaries that were used in the integration test API unit tests. This dictionary can be found [here](../../../../Gds/test/fprime_gds/common/testing_fw/UnitTestDictionary.xml).</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;If a user would like to play with the test API in a unit testing environment they could append their own test cases to the unit tests [here](../../../../Gds/test/fprime_gds/common/testing_fw/api_unit_test.py).</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;**NOTE**: there is no F Prime deployment in these unit tests so data objects need to be added manually.</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;If a user would like to experiment with integration tests on an actual F Prime application, they could modify the Ref app [integration tests](../../../../Ref/test/int/ref_integration_test.py).</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;**NOTE**: running integration tests requires building and running the Ref app.</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;### Sending Commands</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;The Integration Test API provides several methods for sending commands to the user. The most simple is the send_command method. **NOTE**: The command arguments [must be strings](#-GDS-arguments-should-allow-non-string-types) (str) instead of a literal.</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;~~~~{.python}</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;self.api.send_command(&quot;TEST_CMD_1&quot;) # sending a command via mnemonic</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;self.api.send_command(0x01)         # sending the same command via opcode</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;self.api.send_command(&quot;TEST_CMD_2&quot;, [&quot;235&quot;, &quot;43&quot;]) # sending a command with arguments</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;~~~~</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;### Searching for Telemetry</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;The integration Test API provides several different [types of searches](#-types-of-searches). Using a telemetry_predicate will enable the user to better specify the fields of the ChData object to be searched for.  **NOTE**: all searches in the API will return the results of the search. This is so the user may perform additional checks on the results. Whether or not the search was successful is left to the user to check.</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;~~~~{.python}</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;# awaits a telemetry update on the Counter Channel</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;result = self.api.await_telemetry(&quot;Counter&quot;)</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;# same search, but using an id</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;result = self.api.await_telemetry(3)</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;# awaits a Counter update with a value of 8</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;result = self.api.await_telemetry(&quot;Counter&quot;, 8)</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;# searches for an existing telemetry update on the Counter Channel</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;result = self.api.await_telemetry(&quot;Counter&quot;, start=0, timeout=0)</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;# awaits for 7 telemetry updates that are not guaranteed to be in order</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;results = self.api.await_telemetry_count(7, &quot;Counter&quot;)</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;ch_seq = []</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;for i in range(0,10):</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    ch_seq.append(self.api.get_telemetry_pred(&quot;Counter&quot;, i))</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;# awaits for 10 Counter updates with the values 0 through 9 (inclusive).</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;# the resulting sequence must follow the history&#39;s enforced order</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;results = self.api.await_telemetry_sequence(ch_seq)</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;~~~~</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;### Searching for Events</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;The integration Test API provides several different [types of searches](#-types-of-searches). Using an event_predicate will enable the user to better specify the fields of the EventData object to be searched for.  **NOTE**: all searches in the API will return the results of the search. This is so the user may perform additional checks on the results. Whether or not the search was successful is left to the user to check.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;~~~~{.python}</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;# awaits a &quot;CommandReceived&quot; event</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;result = self.api.await_event(&quot;CommandReceived&quot;)</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;# same search, but using an id</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;result = self.api.await_event(0x01)</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;# awaits a &quot;CommandReceived&quot; event with arguments that match</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;result = self.api.await_event(&quot;CommandReceived&quot;, [0x01])</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;# searches for an existing &quot;CommandReceived&quot; event</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;result = self.api.await_event(&quot;CommandReceived&quot;, start=0, timeout=0)</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;# awaits for any 7 events updates that are not guaranteed to be in order</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;results = self.api.await_event_count(7)</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;evr_seq = []</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;for i in range(0,10):</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    evr_seq.append(self.api.get_event_pred(&quot;CommandReceived&quot;, [i]))</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;# awaits for 10 &quot;CommandReceived&quot; events with the argument values 0 through 9 (inclusive).</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;# the resulting sequence must follow the history&#39;s enforced order</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;results = self.api.await_event_sequence(evr_seq)</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;~~~~</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;### Asserting on Telemetry</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;The integration Test API provides several different [types of searches](#-types-of-searches) that can be followed by an assert on whether the search succeeded. Using a telemetry_predicate will enable the user to better specify the fields of the ChData object to be searched for.</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;**NOTE**: all successful search-then-assert calls in the API will return the results of the search. This is so the user may perform additional checks on the results. Because an assertion is raised on search failure, the user can be sure the results reflect a successful test.</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;~~~~{.python}</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;# asserts a telemetry update exists in the current history</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;result = self.api.assert_telemetry(&quot;Counter&quot;)</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;# same search, but using an id</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;result = self.api.assert_telemetry(3)</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;# asserts a &quot;Counter&quot; update with a value of 8 exists in the current history</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;result = self.api.assert_telemetry(&quot;Counter&quot;, 8)</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;# awaits and asserts a &quot;Counter&quot; update was received</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;result = self.api.assert_telemetry(&quot;Counter&quot;, start=&quot;END&quot;, timeout=5)</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;# asserts a count of exactly 7 &quot;Counter&quot; updates exist in the current history</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;results = self.api.assert_telemetry_count(7, &quot;Counter&quot;)</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;ch_seq = []</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;for i in range(0,10):</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    ch_seq.append(self.api.get_telemetry_pred(&quot;Counter&quot;, i))</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;# asserts the history contains a sequence of &quot;Counter&quot; updates with vals 0 through 9</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;# the resulting sequence must follow the history&#39;s enforced order</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;results = self.api.assert_telemetry_sequence(ch_seq)</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;~~~~</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;### Asserting on Events</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;The integration Test API provides several different [types of searches](#-types-of-searches) that can be followed by an assert on whether the search succeeded. Using a event_predicate will enable the user to better specify the fields of the EventData object to be searched for.</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;**NOTE**: all successful search-then-assert calls in the API will return the results of the search. This is so the user may perform additional checks on the results. Because an assertion is raised on search failure, the user can be sure the results reflect a successful test.</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;~~~~{.python}</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;# asserts a &quot;CommandReceived&quot; event is in the history</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;result = self.api.assert_event(&quot;CommandReceived&quot;)</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;# same search, but using an id</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;result = self.api.assert_event(0x01)</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;# asserts a &quot;CommandReceived&quot; event with arguments is in the history</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;result = self.api.assert_event(&quot;CommandReceived&quot;, [0x01])</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;# awaits and asserts on a single &quot;CommandReceived&quot; event</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;result = self.api.assert_event(&quot;CommandReceived&quot;, start=&quot;END&quot;, timeout=5)</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;# asserts that exactly 7 of any event are in the history</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;results = self.api.assert_event_count(7)</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;evr_seq = []</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;for i in range(0,10):</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    evr_seq.append(self.api.get_event_pred(&quot;CommandReceived&quot;, [i]))</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;# asserts tha history has a sequence of 10 &quot;CommandReceived&quot; events with the argument vals 0 through 9 (inclusive).</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;# the resulting sequence must follow the history&#39;s enforced order</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;results = self.api.assert_event_sequence(evr_seq)</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;~~~~</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;### Sending and Searching/Asserting</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;The Test API provides 4 versions of send and search to enable searching for telemetry and events following a command. Internally, these calls record the current position of the history, then send a command then begin a search from the recorded position. All 4 versions support both item and sequence searches depending on whether the channels/events arguments are a list.</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;~~~~{.python}</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;# sends &quot;TEST_CMD_1&quot; then awaits a &quot;CommandCounter&quot; channel update</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;result = self.api.send_and_await_telemetry(&quot;TEST_CMD_1&quot;, channels=&quot;CommandCounter&quot;)</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;# sends &quot;TEST_CMD_1&quot; then awaits a sequence of &quot;CommandCounter&quot; then five &quot;Counter&quot; updates</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;seq = [&quot;CommandCounter&quot;] + [&quot;Counter&quot;] * 5</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;results = self.api.send_and_await_telemetry(&quot;TEST_CMD_1&quot;, channels=seq)</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;# sends &quot;TEST_CMD_1&quot; then awaits and asserts a &quot;CommandCounter&quot; channel update</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;result = self.api.send_and_assert_telemetry(&quot;TEST_CMD_1&quot;, channels=&quot;CommandCounter&quot;)</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;# sends &quot;TEST_CMD_1&quot; then awaits a &quot;CommandReceived&quot; event</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;result = self.api.send_and_await_event(&quot;TEST_CMD_1&quot;, events=&quot;CommandReceived&quot;)</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;# sends &quot;TEST_CMD_1&quot; then awaits a sequence of &quot;CommandReceived&quot; then five &quot;SeverityDIAGNOSTIC&quot; events</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;seq = [&quot;CommandReceived&quot;] + [&quot;SeverityDIAGNOSTIC&quot;] * 5</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;results = self.api.send_and_await_event(&quot;TEST_CMD_1&quot;, events=seq)</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;# sends &quot;TEST_CMD_1&quot; then awaits and asserts &quot;CommandReceived&quot; event</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;result = self.api.send_and_assert_event(&quot;TEST_CMD_1&quot;, events=&quot;CommandReceived&quot;)</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;~~~~</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;### Using predicates</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;The API uses predicates to identify valid values in searches and filter data objects into histories.</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;The provided [predicates](#-predicates) can be combined to make specifying an event message or channel update incredibly flexible. When using predicates, it is important to understand that a predicate is used to determine if a value belongs to a set of values that satisfies a rule. Not satisfying a rule [**DOES NOT** imply](#-Interpreting-predicates-correctly) that a value satisfies a second complimentary rule.</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;#### Combining Predicates</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;One pattern is to have multiple predicate specifications and want to combine these.</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;~~~~{.python}</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;from fprime_gds.common.testing_fw import predicates</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;gt_pred = predicates.greater_than(8)</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;eq_pred = predicates.equal_to(&quot;some_string&quot;)</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;# satisfies any will evaluate true if any of it&#39;s predicates are valid</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;or_pred = predicates.satisfies_any([gt_pred, eq_pred])</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;or_pred(121)           # evaluates True</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;or_pred(&quot;some_string&quot;) # evaluates True</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;rng_pred = predicates.within_range(0, 100)</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;ne_pred = predicates.not_equal_to(50)</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;# a valid value must be within the range 0 to 100 and must not be 50.</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;and_pred = predicates.satisfies_all([rng_pred, ne_pred])</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;or_pred(15) # evaluates True</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;or_pred(50) # evaluates False</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;~~~~</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;#### Set Predicates</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;Another pattern is to specify a collection and check if the value is a member of that collection.</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;~~~~{.python}</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;from fprime_gds.common.testing_fw import predicates</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;is_in_pred = predicates.is_a_member_of([&quot;A&quot;, 2, False])</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;isnt_in_pred = predicates.is_not_a_member_of([&quot;A&quot;, 3])</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;is_in_pred(2)     # evaluates True</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;is_in_pred(False) # evaluates True</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;is_in_pred(&quot;A&quot;)   # evaluates True</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;isnt_in_pred(&quot;A&quot;) # evaluates False</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;~~~~</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;This pattern is useful for creating filters. For example, if we want to search or filter for certain event severities.</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;~~~~{.python}</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;from fprime_gds.common.testing_fw import predicates</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;from fprime_gds.common.utils.event_severity import EventSeverity</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;severities = []</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;severities.append(EventSeverity.FATAL)</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;severities.append(EventSeverity.WARNING_HI)</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;sev_pred = predicates.is_a_member_of(severities)</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;# event pred will now identify any event with either Fatal or HI Warning severity</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;event_pred = self.api.get_event_pred(severity=sev_pred)</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;~~~~</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;#### Specifying data objects</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;The test API has two methods to help create event and telemetry predicates: `api.get_telemetry_pred` and `api.get_event_pred`. These methods overload argument types such that fields can be specified as a value (becomes an equal_to predicate) or they can be specified by user-created predicates. To specify the type of event/telemetry, the helpers can accept both mnemonics (str) or ids (int).</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;~~~~{.python}</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;from fprime_gds.common.testing_fw import predicates</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;from fprime_gds.common.utils.event_severity import EventSeverity</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;# both predicates will now identify any event with a command severity</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;sev_pred = predicates.equal_to(EventSeverity.COMMAND)</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;event_pred1 = self.api.get_event_pred(severity=sev_pred)</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;event_pred2 = self.api.get_event_pred(severity=EventSeverity.COMMAND)</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;# both predicates will now identify any &quot;CommandCounter&quot; Update</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;ch_pred1 = self.api.get_telemetry_pred(&quot;CommandCounter&quot;)</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;ch_pred2 = self.api.get_telemetry_pred(1)</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;~~~~</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;### Using sub-histories</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;One patterns that the API supports is creating a sub-history of telemetry or event objects. There are several [behaviors](#-Substituting-a-history-(history-argument)) to understand with sub-histories that are outlined in the API features section. Below is an example of how to create sub-histories, search on sub-histories, and remove sub-histories. Sub-histories can be created for both telemetry and event data objects.</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;~~~~{.python}</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;from fprime_gds.common.testing_fw import predicates</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;from fprime_gds.common.utils.event_severity import EventSeverity</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;# Creates an event sub-history with the default object ordering (fsw_order).</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;fsw_subhist = self.api.get_event_subhistory()</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;# Creates a filtered sub-history with all events of COMMAND severity</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;event_filter = self.api.get_event_pred(severity=EventSeverity.COMMAND)</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;filt_subhist = self.api.get_event_subhistory(event_filter)</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;# Creates an event sub-history with ERT ordering</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;ert_subhist = self.api.get_event_subhistory(fsw_order=False)</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;# Substitutes a sub-history into an API assert</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;result = self.api.assert_event(&quot;SeverityCOMMAND&quot;, history=filt_subhist)</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;# If a sub-history hasn&#39;t been removed. It can also be awaited on.</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;results = self.api.await_event_count(5, history=fsw_subhist)</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;# De-register a sub-history from the GDS</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;self.api.remove_event_subhistory(ert_subhist)</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;~~~~</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;### Search returns</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;API calls that perform a search and do not end by raising and Assertion Error will return the results of the search. This is so that the user can find some event or channel updates then perform additional checks on the results or use the results to specify a future search.</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;Here is an example of awaiting a counter sequence and verifying that the sequence always ascends.</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;~~~~{.python}</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;search_seq = [&quot;Counter&quot;] * 5</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;results = self.api.await_telemetry_sequence(search_seq)</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;last = None</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;for update in results:</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    if last is not None:</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        assert update.get_val() &gt; last.get_val()</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    last = update</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;~~~~</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;### Assert Helpers</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;Another feature provided to the user is the ability to raise asserts with formatted assert messages reflected in the test logs.</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;~~~~{.python}</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;from fprime_gds.common.testing_fw import predicates</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;# assert on values that can be evaluated as True or False</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;self.api.test_assert(2 &lt; 3, &quot;The number two should be less than three&quot;)</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;# assert a predicate on a value the log message will be more descriptive.</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;lt_pred = predicates.less_than(3)</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;self.api.predicate_assert(lt_pred, 2, &quot;The number two should be less than three&quot;)</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;~~~~</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;Assert helpers can be configured not to raise an assertion error. They will also return True if the assertion passed or False if it failed. This can be used to perform multiple checks. This behavior is referred to as expecting instead of asserting.</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;~~~~{.python}</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;# a variable to accumulate whether all checks were successful</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;all_passed = True</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;all_passed &amp;= self.api.test_assert(1 &lt; 3, &quot;1 should be less than 3&quot;, expect=True)</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;all_passed &amp;= self.api.test_assert(2 &lt; 3, &quot;2 should be less than 3&quot;, expect=True)</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;# this call will not raise an assert, but will return False</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;all_passed &amp;= self.api.test_assert(3 &lt; 3, &quot;3 should not be less than 3&quot;, expect=True)</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;# checks that previous expectations passed.</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;self.api.test_assert(all_passed, &quot;All checks should have passed, see log&quot;)</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;~~~~</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;### Using TimeTypes</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;The TimeType serializable stores timestamp information for both events and telemetry. As part of the development for the integration test API, the TimeType object was updated to support rich comparison and math operations. These are implemented with python special methods and are compatible with floating point numbers.</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;**NOTE**: Math operations will return a new TimeType object with the resulting value and the TimeType serializable does not allow negative values.</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;**NOTE**: Math operations between TimeType objects of different time_bases or time_context will return a TimeType with the same base and context as the left operand.</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;~~~~{.python}</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;from fprime.common.models.serialize.time_type import TimeType</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;t0 = TimeType() # 0.0 seconds</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;t1 = t0 + 1   # Assigns a TimeType with a time of 1.0 seconds</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;t3 = t0 + 3   # Assigns a TimeType with a time of 3.0 seconds</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;t2 = t3 - t1  # Assigns a TimeType with a time of 2.0 seconds</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;t0 = t1 - t3  # Assigns a TimeType with a time of 0.0 seconds (negatives are set to 0)</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;t15 = t3 / 2  # Assigns a TimeType with a time of 1.5 seconds</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;t6 =  t2 * t3 # Assigns a TimeType with a time of 6.0 seconds</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;t1 &gt; 0   # evaluates True</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;t1 &gt; t0  # evaluates True</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;t6 == 6  # evaluates True</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;t3 &gt;= t2 # evaluates True</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;~~~~</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;Accessing TimeStamps from from event and channel data types can be done with the `get_time()` getter. These comparisons can be very useful in testing whether FSW meets timing requirements.</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;~~~~{.python}</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;seq = [&quot;Counter&quot;] * 5</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;results = self.api.await_telemetry_sequence(seq)</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;# checks that all adjacent elements in the sequence happened within 2 seconds of each other</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;last = None</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;for result in results:</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    if last is not None:</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        assert result.get_time() - last.get_time() &lt; 2</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    last = result</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;~~~~</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;### Recording a point in the histories</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;**NOTE** There is an [issue](#-Latest-FSW-Time-Getter-is-incorrect) with how get_latest_time() is implemented. Getting history markers should be updated to be more robust.</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;If a user wants to record a marker, send some commands and then come back and evaluate items after that marker, then they can do the following: This all will return the latest FSW TimeStamp when the histories are ordered by FSW time.</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;~~~~{.python}</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;# if using time-ordered histories</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;fsw_start = self.api.get_latest_time()</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;# do some stuff</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;self.api.send_command(&quot;TEST_CMD_1&quot;)</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;# search</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;results = self.api.assert_telemetry(&quot;Counter&quot;, start=fsw_start)</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;~~~~</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;If using receive-ordered histories, this point should be marked as an index.</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;~~~~{.python}</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;# if using re-ordered histories</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;ro_start = self.api.get_telemetry_test_history().size()</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;# do some stuff</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;self.api.send_command(&quot;TEST_CMD_1&quot;)</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;# search</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;results = self.api.assert_telemetry(&quot;Counter&quot;, start=ro_start)</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;~~~~</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;## Anti-patterns</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;***</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;### Asserting none of a data object were received</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;One thing a user might want to do is assert that no instances of a certain update or message were received. This can be done using a count search for zero items on **existing history items only**.  This constraint is because the count search behaves as follows:</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;1. count all items in the search scope of the current history</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;2. await future updates until a correct count is received.</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;So, if count search is awaiting zero items, it will exit immediately and claim success where the user may believe it searched future objects.</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;~~~~{.python}</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;# incorrect, this will exit as the search found 0 items and was looking for 0 items</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;self.api.assert_telemetry_count(0, start=&quot;END&quot;, timeout=5)</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;~~~~</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;If the user wants to assert that none of a certain type of object were received in the future scope, they should wait for items to accumulate then assert on existing scope.</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;~~~~{.python}</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;import time</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;# correct, way to say no telemetry was received in now or in the next 5 seconds.</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;time.sleep(5)</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;self.api.assert_telemetry_count(0)</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;~~~~</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;### Specifying sequence searches with timestamps</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;The doc-strings in the API recommend not specifying FSW timestamps when searching for sequences. This is simply because the timestamps can change depending on when tests are run. the easiest way to verify timing is to process timestamps after a search is completed.</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;### No-scope search</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;Because searches allow the user to define the [existing and future scope to search](), it is possible to completely de-scope a search.</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;~~~~{.python}</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;# setting timeout to zero on await functions w/o a start, results in no scope</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;self.api.await_telemetry_count(5, timeout=0)</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;# setting start to END on assert functions w/o a timeout, results in no scope</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;self.api.assert_telemetry_count(5, start=&quot;END&quot;)</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;# setting start to END and timeout to zero on any search, results in no scope</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;self.api.assert_telemetry_count(5, start=&quot;END&quot;, timeout=0)</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;self.api.await_telemetry_count(5, start=&quot;END&quot;, timeout=0)</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;~~~~</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;### Interpreting predicates correctly</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;Predicates may compare a value to another, but their purpose isn&#39;t to compare two objects, rather to identify objects that satisfy a certain property or rule. If a user uses a greater_than predicate to see if a string is greater than a numeric value, 8, the predicate will return False. The correct interpretation is that the string is not in the set of values that are greater than 8. It is incorrect to say the string is less than 8.</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;~~~~{.python}</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;from fprime_gds.common.testing_fw import predicates</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;gt_pred = predicates.greater_than(8)</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;gt_pred(9)        # evaluates True</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;gt_pred(7)        # evaluates False</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;gt_pred(&quot;string&quot;) # evaluates False: String is not a value that is greater than 8</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;lte_pred = predicates.less_than_or_equal_to(8)</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;lte_pred(8)        # evaluates True</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;lte_pred(7)        # evaluates True</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;lte_pred(&quot;string&quot;) # evaluates False: String is not a value that is less than 8</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;~~~~</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;**Takeaway**: using invert to try to convert a greater_then predicate to a less_than_or_equal_to predicate will introduce false positives if the user isn&#39;t aware of what a predicate is describing</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;~~~~{.python}</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;from fprime_gds.common.testing_fw import predicates</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;gt_pred = predicates.greater_than(8)</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;lte_pred = predicates.less_than_or_equal_to(8)</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;not_lte_pred = predicates.invert(lte_pred) # inverts how a predicate evaluates.</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;not_lte_pred(&quot;string&quot;) # evaluates True: because &quot;string&quot; is not a value that is less than 8</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;gt_pred(&quot;string&quot;) # evaluates False: String is not a value that is greater than 8</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;~~~~</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;## API Installation Requirements</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;***</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;The following libraries were added to the [GDS pip requirements file](../../../../mk/python/pip_required_gds.txt).</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;| Library| Provides|</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;| :--| :--|</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;|openpyxl| ability to create formatted .xlsx files|</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;|sphinx| ability to generate code documentation</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;|sphinx-markdown-builder| ability to output code docs as markdown files|</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;## Integration Test API Organization</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;***</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;### Integration Test API Outline</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;The actual Test API is a very long class that has helpful doc-strings, but these don&#39;t convey its organization while skimming. Below is a table of how the API is organized with a brief summary of each section:</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;| Test API Section| Section Description| Methods|</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;| :----| :----| :----|</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;| API Functions| These functions give access to helpful API features.| start_test_case, log, get_latest_time, test_assert, predicate_assert, clear_histories, set_event_log_filter|</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;| History Functions| These functions give the user access to test histories and the ability to create sub-histories.| get_command_test_history, get_telemetry_test_history, get_event_test_history, get_telemetry_subhistory, remove_telemetry_subhistory, get_event_subhistory, remove_event_subhistory|</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;| Command Functions| These functions provide the ability to send commands and search for events/telemetry.| translate_command_name, send_command, send_and_await_telemetry, send_and_await_event|</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;| Command Asserts| These functions send commands then perform search and asserts on the histories| send_and_assert_telemetry, send_and_assert_event|</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;| Telemetry Functions| These functions help specify and search for telemetry updates.| translate_telemetry_name, get_telemetry_pred, await_telemetry, await_telemetry_sequence, await_telemetry_count|</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;| Telemetry Asserts| These functions search and assert for telemetry updates.| assert_telemetry, assert_telemetry_sequence, assert_telemetry_count|</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;| Event Functions| These functions help specify and search for event messages.| translate_event_name, get_event_pred, await_event, await_event_sequence, await_event_count|</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;| Event Asserts| These functions search and assert for event messages.| assert_event, assert_event_sequence, assert_event_count|</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;| History Searches| These functions implement the various searches in the API. They aren&#39;t meant for the user, but are mentioned to highlight where searches are actually performed.| __search_test_history, find_history_item, find_history_sequence, find_history_count|</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;For detailed descriptions of the API&#39;s methods see the IntegrationTestAPI&#39;s sphinx documentation [here](markdown/contents.md). One thing to note about the API&#39;s implementation is that the API uses layering so that all searches can be defined by common arguments and share similar behaviors. A diagram of this layering is provided below. In the diagram, each box is an API call. The arrows show how the calls are layered.</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;![Diagram of GDS Search Layering](assets/APISearchLayering.png)</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;The table below outlines the additional functionality provided by each layer in above diagram.</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;|Layer Name| Diagram Row| Delegated Functionality|</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;| :---| ---:| :---|</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;| Assert Layer| 1| This layer adds an assert to the end of the search to check if the search completed successfully.|</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;| Await Layer| 2| This layer differentiates whether the particular search is acting on the event or telemetry history.|</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;| Search Type Layer| 3| This layer determines what kind of search is being conducted. The API provides 3 types: item, count, and sequence.|</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;| Search Helper| 4| The search helper provides the logic, logging, search scoping. and sub-history functionality for all searches.|</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;### Integration Test Classes</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;The API uses several classes to support its features. They were organized within the already-present GDS class folder structure. A component view of the integration test API and its relationship to the Integration Tests and the GDS is shown in the diagram below. For simplicity, the predicates library has been left out, but it can be used by Integration tests and is presently used by the Test API and Test History layers.</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;![Component View of the Test Framework](assets/TestFwComponentView.png)</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;## Important API Features</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;***</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;### Specifying Search Scope (start and timeout arguments)</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;All searches in the integration test API can be configured to search part of the existing history (Current Search Scope) and/or part of the future history (Future Search Scope). The API relies on two common variables to define the scope of what is searched: `start` and `timeout`.</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;The `start` argument specifies the Current Search Scope in an existing history. `start` is used to choose the earliest item that the search will evaluate in a given history&#39;s ordering. `start` can be either an index in the history&#39;s ordering, a predicate, or a TimeType timestamp. Because the Test API&#39;s histories support re-ordering, the TimeType timestamp is the most reliable marker for `start`. A predicate can also be used to specify a `start`. For example, if the assert is only to begin after a certain EVR was received then an event_predicate instance could be used to find the first element to search. If `start` is not specified, see the particular API function to learn the default behavior. For convenience, the API includes a member variable, `NOW`, that will begin the search after all existing history when `NOW` is passed as the `start` argument.</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;The `timeout` argument specifies the Future Search Scope (FSS) in seconds. FSS is how long a search should await until the search criteria is met. Searches that await a yet-to-be-received item can only specify how long in seconds. A `timeout` of zero seconds will skip awaiting at all.</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;![Search Scope diagram](assets/APISearchScope.png)</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;All search methods can either be configured with CSS, FSS, or both.</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;### Types of searches</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;The integration test API defines three types of searches: item, count, and sequence. Each of these searches has an [assert version and an await version](#default-search-scope-for-await-and-assert-calls) as well as a version for both telemetry and event versions. This means the API has a total of 12 search calls.</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;| Search Type| Description|</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;| :---| :---|</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;| item search| an item search is searching for a specific item in the history. The result will return a single data object|</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;| count search| a count search is searching for a number of items in history. The result is a group of items that isn&#39;t necessarily ordered according to the history. |</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;| sequence search| a sequence search is searching for an ordered sequence of items in the history. The result is an ordered list of items that is ordered with respect to the given history&#39;s order.|</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;#### Default Search Scope for await and assert calls</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;The integration test API provides to versions of each type of search: the await version will always return results and the assert version will search and then assert on whether the search completed successfully. For any given combination of search type (item, count, sequence) and search behavior (await or assert), the API allows the user to reconfigure the search scope with CSS, FSS, or both. Because all search calls in the API can manipulate this scope, the API doesn&#39;t provide different combinations of search scopes as different API calls. However, the API does provide default arguments for its searches and name its searches accordingly. This was done to satisfy the common request to support await functionality explicitly even though this behavior is already being provided by all search types.</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;| Prefix| Default Behavior|</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;| :---| :---|</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;| `await_`| By default, all search-only calls begin with `await_` and will only search for future data objects for at most 5 seconds|</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;| `assert_`| By default, all search and assert calls begin with `assert_` and will search all current data objects from the beginning of the history|</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;### Substituting a history (history argument)</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;Another useful feature in the integration test API is the ability to create filtered sub-histories and substitute them into any regular API call. This feature provides the user with the ability to manage their own histories. The API methods that support this are get_telemetry_subhistory, remove_telemetry_subhistory, get_event_subhistory, remove_event_subhistory. There are several behaviors to know when creating sub-histories.</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;- When creating a sub-history, the get_ calls allow the user to specify whether the history will be ordered by receive order or by flight software time (FSW) order. This is done with the `fsw_order` argument (ordered by FSW time is default).</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;- When creating a sub-history, the get_ calls allow the user to optionally specify a predicate filter to determine which items to allow into the sub-history (allows all by default). These filters should be a predicate composed of either telemetry_predicate&#39;s or event_predicate&#39;s depending on the type of sub-history.</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;- A new subhistory WILL be registered with the GDS to automatically receive data objects from its respective decoder (event/telemetry).</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;- A new subhistory will NOT be managed by the Test API. It will not be cleared nor de-registered when a test case ends.</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;Removing a sub-history is currently permanent as th API doesn&#39;t provide for sub-histories to be re-registered. Removing a sub-history will unsubscribe it from the GDS and it will no longer receive new data objects.</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;### Data object specifiers (event and channel arguments)</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;Throughout the API specifying an event message or channel update to search for is very flexible. This is because all search types use predicates to specify a single or multiple objects when searching. The word used to describe this overloading behavior in the API is `specifier`. The phrases to look for in doc-strings are channel specifiers and event specifiers.</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;Providing this flexibility in the `event` and `channel` arguments is done via the get_event_predicate and get_telemetry_predicate calls. These calls provide argument-overloading when specifying different fields of ChData or EventData objects. The way this works for most fields is that if the user specifies the field as a value, the returned predicate will check that data object&#39;s corresponding field against that value; however, if the user specifies the field as a predicate, then the user&#39;s predicate will be called on that field instead. This enables using the predicates library to do more complex checks on certain fields.</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;In addition to specifying values by value or predicate, the get_event_predicate and get_telemetry_predicate calls also access the deployment dictionary to allow the user to specify a data object type by mnemonic or ID.</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;### API Test Log</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;When an output location is specified, the integration test API will generate a formatted test log as a .xlsx file.</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;There are four columns in this file. They are summarized in the table below:</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;| Log Column| Description|</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;| :---| :---|</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;| Log Time| A time stamp of when the message was logged. Format &quot;HH:mm:ss.us&quot;|</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;| Case ID| An identifier for a test case. This field will help navigate when looking through long logs.|</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;| Sender| Describes where the message originated (GDS, Test API, API user). Note: all log messages are still made through API calls.|</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;| Message| A string message recording test behavior.</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;The following image is an excerpt from an API log generated by the Ref App integration tests.</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;![Test Log Example](assets/TestLogExample.png)</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;The following table summarizes the color meanings from API-generated messages.</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;| Color| Meaning|</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;| :---| :---|</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;| Red| red indicates failed asserts. If a red log message is from the Test API, then an assertion error was raised by an API call.|</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;| Orange| orange indicates failed expectations and warnings.|</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;| Yellow| yellow indicates the beginning and end of any search.|</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;| Green| green indicates successful asserts and expectations within API calls.|</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;| Blue| blue indicates interlaced EVR&#39;s.|</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;| Purple| purple indicates commands that were sent to flight software.|</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;| Gray| gray indicates the beginning of a new test case.|</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;| White| white or blank fill is used for diagnostic messages.|</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;### Predicates</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;The integration test API uses predicates for filtering, searching and asserting. A predicate is a callable class that evaluates if an object/value satisfies a certain property. Predicates used by the API are defined [here](../../../../Gds/src/fprime_gds/common/testing_fw/predicates.py). The API uses Duck Typing to determine what can and cannot be used as a predicate; therefore, a user of the API can very easily create their own. Below is a table of how predicates are organized with a brief summary of each section:</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;| Predicate Section| Section Description| Functions/predicates|</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;| :----| :----| :----|</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;| Base class/helpers| This section contains the parent class for predicates and helpers to carry out duck-typing and string formatting.| class predicate, is_predicate(), get_descriptive_string()|</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;| Comparison Predicates| These predicates evaluate basic comparison rules (&lt;, =, &gt;, !=).| less_than, greater_than, equal_to, not_equal_to, less_than_or_equal_to, greater_than_or_equal_to, within_range|</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;| Set Predicates| These predicates evaluate whether predicates belong to a set of objects.| is_a_member_of, is_not_a_member_of|</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;| Logic Predicates| These predicates can be used to combine/manipulate other predicates with basic boolean logic.| always_true, invert (not), satisfies_all (and), satisfies_any (or)|</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;| Test API Predicates| These predicates operate specifically on the fields on the ChData and EventData objects. They are used by the API to specify event and telemetry messages.| args_predicate, event_predicate, telemetry_predicate|</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;## Known bugs</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;***</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;### Latest FSW Time Getter is incorrect</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;Because it was demonstrated that data objects can come in a different receive order than they were created in FSW, the `get_latest_time()` method is not correct. When implemented, it was assumed that all history items would be enqueued in the same order that they were created. This is no longer a safe assumption. Effectively `get_latest_time()` is returns an approximation of the latest time.</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;I see two options to address this:</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;1. Replacing the Ram Histories in the GDS with Chronological Histories</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;2. Having the TestAPI be subscribed to all data objects and calculate latest time as items are enqueued.</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;### The openpyxl library has thrown WorkbookAlreadySaved error</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;While running unit tests on the API, there was an error thrown by openpyxl that caused the log to close early. The behavior wasn&#39;t able to be recreated, but the [Test Logger](../../../../Gds/src/fprime_gds/common/logger/test_logger.py) was updated to [catch the exception](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/logger/test_logger.py#L124) to prevent tests from failing due to the logger.</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;~~~~</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;___________________________________ APITestCases.test_find_history_item _________________________________</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;self = &lt;WriteOnlyWorksheet &quot;Sheet&quot;&gt;, row = [&lt;Cell &#39;Sheet&#39;.A1&gt;, &lt;Cell &#39;Sheet&#39;.A1&gt;, &lt;Cell &#39;Sheet&#39;.A1&gt;, &lt;Cell &#39;Sheet&#39;.A1&gt;]</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;    def append(self, row):</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        &quot;&quot;&quot;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;        :param row: iterable containing values to append</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;        :type row: iterable</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        &quot;&quot;&quot;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        if (not isgenerator(row) and</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;            not isinstance(row, (list, tuple, range))</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;            ):</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;            self._invalid_row(row)</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        self._max_row += 1</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        if self.writer is None:</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;            self.writer = self._write_header()</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;            next(self.writer)</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;        try:</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;&gt;           self.writer.send(row)</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;E           StopIteration</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;/usr/lib/python3/dist-packages/openpyxl/writer/write_only.py:241: StopIteration</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;During handling of the above exception, another exception occurred:</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;self = &lt;api_unit_test.APITestCases testMethod=test_find_history_item&gt;</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;    def setUp(self):</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;        for t in self.threads:</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            if t.isAlive():</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                t.join()</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;        self.threads.clear()</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        count = len(self.case_list)</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;&gt;       self.api.start_test_case(self._testMethodName, count)</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;test/fprime_gds/common/testing_fw/api_unit_test.py:102:</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;src/fprime_gds/common/testing_fw/api.py:96: in start_test_case</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    self.__log(msg, TestLogger.GRAY, TestLogger.BOLD, case_id=case_id)</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;src/fprime_gds/common/testing_fw/api.py:1214: in __log</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;    self.logger.log_message(message, sender, color, style, case_id)</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;src/fprime_gds/common/logger/test_logger.py:121: in log_message</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    self.worksheet.append(row)</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;/usr/lib/python3/dist-packages/openpyxl/writer/write_only.py:243: in append</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    self._already_saved()</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;self = &lt;WriteOnlyWorksheet &quot;Sheet&quot;&gt;</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;    def _already_saved(self):</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;&gt;       raise WorkbookAlreadySaved(&#39;Workbook has already been saved and cannot be modified or saved anymore.&#39;)</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;E       openpyxl.utils.exceptions.WorkbookAlreadySaved: Workbook has already been saved and cannot be modified or saved anymore.</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;/usr/lib/python3/dist-packages/openpyxl/writer/write_only.py:247: WorkbookAlreadySaved</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;------------------------------------------ Captured stdout call ---------------------------------</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;10:46:08.703826 [Test API] [STARTING CASE] test_find_history_item</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;~~~~</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;To fully resolve this would require being able to reproduce the issue and explain why the test log failed. However, the test logger should at least have a reliable csv format that won&#39;t stop logging if the xml logger fails.</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;#### Adding CSV Logger to Test Logger</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;Recommendation for adding a csv logger to the TestLogger class:</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;1. Set up the csv log file in the constructor [here](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/logger/test_logger.py#L49).</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;2. Add a `_log_csv_row()` helper along similar lines to the `_get_ws_row()` helper [here](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/logger/test_logger.py#L159)</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;3. Log the start time at the top of the file like the excel output does [here](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/logger/test_logger.py#L85).</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;4. Log the column headers to csv like the excel does [here](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/logger/test_logger.py#L88).</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;5. Log messages in the lock block [here](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/logger/test_logger.py#L119).</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;## Idiosyncrasies</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;***</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;In this document, idiosyncrasies refer to needed-improvements and future features that should/could be in the Test API. The API in its present state is functional, but these were identified as nice-to-haves or potential issues to be revised later.</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;### Timeout implementation</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;Presently timeouts are using the signal library and throw an exception to end the search. This timeout behavior can be modified very easily by changing the [__search_test_history](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/6cd4c8007a7f562d5b0b616eb494270ac5c7b95d/Gds/src/fprime_gds/common/testing_fw/api.py#L911) method. All searches use this method to accomplish scoping, logging and history substitution. Changing the timeout to something like below  would be better.</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;~~~~{.python}</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;# in IntegrationTestAPI&#39;s __search_test_history method on ~line 912 of api.py</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;if timeout:</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;    self.__log(name + &quot; now awaiting for at most {} s.&quot;.format(timeout))</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    end_time = time.time() + timeout</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;    while True:</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;        new_items = history.retrieve_new()</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;        for item in new_items:</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;            if searcher.incremental_search(item):</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;                return searcher.get_return_value()</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;        if time.time() &gt;= end_time:</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;            msg = name + &quot; timed out and ended unsuccessfully.&quot;</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;            self.__log(msg, TestLogger.YELLOW)</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;            break</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;        time.sleep(0.1)</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;else:</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    self.__log(name + &quot; ended unsuccessfully.&quot;, TestLogger.YELLOW)</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;return searcher.get_return_value()</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;~~~~</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;**NOTE**: The above code hasn&#39;t been tested and may have issues if the system time changes: `time.time()`.</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;### Implementing ERT ordering in Chronological History and in the GDS</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;In order to properly support ERT ordering, I recommend:</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;1. Add a TimeType field to the [SysData](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/data_types/sys_data.py#L19) class and add an accessor for `get_ert_time()`.</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;2. Have the GDS record ERT at some point.</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;3. Preserve the use of the `fsw_order` argument in the test API&#39;s [constructor](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/testing_fw/api.py#L29) and [sub-history](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/testing_fw/api.py#L244) functions by passing the fsw_order argument to the chronological [history constructor](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/history/chrono.py#L23).</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;4. Modify chronological history to choose whether to use `get_time()` or `get_ert_time()` for its ordering/returning operations:</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;    - [clearing history](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/history/chrono.py#L111)</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;    - `__insert_chrono()` [helper](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/history/chrono.py#L165)</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;    - `__get_index()` [helper](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/history/chrono.py#L206)</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;#### Better History Markers</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;As part of the work to add ERT and have chronological histories work for both ERT and FSW orders, histories should be updated to have a `get_current_marker()` method. This will allow the histories to specify the best way to mark a position with respect to their own implementations. For reference: ChronologicalHistories should use a TimeType, Ram and Test History should use an index.</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;### Color-coding interlaced Events in the API Log</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;One feature that wasn&#39;t completed this summer was to color-code interlaced event logs based on severity. Presently, interlacing events are implemented by making the API a consumer of the event decoder in the GDS and then filtering events. Modifying the color of these log messages can be done [here](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/testing_fw/api.py#L1258).</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;### Moving StandardPipeline to API constructor</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;Presently, a user of the integration test API needs to instantiate the GDS manually before instantiating the API. This code should really be moved to inside the API. To do this, the IntegrationTestAPI&#39;s [constructor](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/d0309a9e265b8650ca6be03b9132dfdc682e0622/Gds/src/fprime_gds/common/testing_fw/api.py#L27) should be modified to include the pipeline instantiation and the API&#39;s [teardown](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/d0309a9e265b8650ca6be03b9132dfdc682e0622/Gds/src/fprime_gds/common/testing_fw/api.py#L64) method should be modified to disconnect from the F Prime deployment.</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;#### Modification to the Integration Test API</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;~~~~{.python}</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;# import statements on ~line 17 of api.py with other GDS includes</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;from fprime_gds.common.pipeline.standard import StandardPipeline</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;from fprime_gds.common.utils.config_manager import ConfigManager</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;# ~ IntegrationTestAPI constructor on ~line 29 of api.py</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;def __init__(self, dict_path, address, port, log_prefix=None, fsw_order=True):</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;    &quot;&quot;&quot;</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;    Initializes API: constructs and registers test histories.</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    Args:</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;        dict_path: dictionary path (str). Used to setup loading of dictionaries.</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;        address: address of middleware (str)</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;        port: port of middleware (int)</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        log_prefix: an optional output destination for the api test log</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;        fsw_order: a flag to determine whether the API histories will maintain FSW time order.</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;    &quot;&quot;&quot;</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;    # add these lines</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;    self.pipeline = StandardPipeline()</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;    self.pipeline.setup(ConfigManager(), dict_path)</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    self.pipeline.connect(address, port)</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;    # ... the rest of IntegrationTestAPI.__init__</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;# ~ IntegrationTestAPI teardown on ~line 73 of api.py</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;def teardown(self):</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    &quot;&quot;&quot;</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;    To be called once at the end of the API&#39;s use. Disconnects from the deployment,</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    closes the test log, and clears histories.</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    &quot;&quot;&quot;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;    # add this line</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    self.pipeline.disconnect()</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;    # ... the rest of IntegrationTestAPI.teardown</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;~~~~</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;#### Cleaned up version of how instantiating could look</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;~~~~{.python}</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;from fprime_gds.common.testing_fw.api import IntegrationTestAPI</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;from fprime_gds.common.testing_fw import predicates   # Recommended, but not required</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;# instantiate Test API</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;dict_path = &quot;/path/to/AppDictionary.xml&quot;</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;server_ip = &quot;127.0.0.1&quot;</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;port = 50000</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;log_prefix = &quot;/path/to/api/output/directory&quot;</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;api = IntegrationTestAPI( dict_path, server_ip, port, log_prefix)</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;# user can now use the Test API</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;api.assert_telemetry(&quot;SOME_CHANNEL_MNEMONIC&quot;)</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;~~~~</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;### Using GDS Prefix to output the test Logs</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;Currently the StandardPipeline (GDS Helper layer) uses a path to a directory to specify an output location for log directories. When GDS instantiation is [moved inside](#-Moving-StandardPipeline-to-API-constructor) of IntegrationTestAPI&#39;s constructor, this prefix and directory should be used to output test logs as well.</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;### Better test identifiers using decorators</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;When a new test case [is started](https://github.jpl.nasa.gov/FPRIME/fprime-sw/blob/717bc6fab85c53680108fc961cad6338e779816f/Gds/src/fprime_gds/common/testing_fw/api.py#L85), the API user can specify a `case_id` that will be used in the logs to identify the current test case without scrolling to the test case header. Future uses of the API should investigate using decorators to specify an ID to put in this column. Present tests just use a counter and assign a number to each test case.</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;### GDS command arguments should allow non-string types</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;Presently, the GDS doesn&#39;t accept command arguments that aren&#39;t strings. This is kind of annoying and means the test API is more flexible about</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;### F Prime CI/CD Test Runner</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;During the development of the API it became apparent that the Test Runner would have bled into the scope of other testing efforts at the time. So the test API work de-scoped developing a test runner script. However, because discussions were had on what the Test Runner should do, the requirements for the Test Runner are still captured here.</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;- The Test Runner shall collect artifacts to record the condition of the tests.</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;  - History logs</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;  - Copies of the FSW dictionaries</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;  - A copy of the FSW binary</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;- The Test Runner shall collect files to record the results of the tests.</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;  - Test logs</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;  - Test reports</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;- The Test Runner shall support specifying a deployment directory to discover and run Integration Tests.</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;- The Test Runner should be usable by CI/CD setup.</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;- The Test Runner should support different test configurations</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;- The Test Runner should have a Command Line Interface</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;## Generating Code Documentation</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;***</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;If the API is modified and a developer wants to generate new documentation, they can navigate to the sphinx directory and run the command `make markdown` to create new code docs. The files will be in `fprime-sw/Gds/docs/testAPI/sphinx/build/markdown` they should be moved to `fprime-sw/Gds/docs/testAPI/markdown` and committed there.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="v2_80_80_2_users_guide_2dev_2test_a_p_i_2user__guide_8md.html">user_guide.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
