<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Operating Abstraction Layer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.6.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('autotoc_md944.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Operating Abstraction Layer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The framework provides OS services abstraction classes to allow developers to write code in a more portable fashion. Implementations of these classes are provided for Unix variants (POSIX), and Mac OS. Additional ports can be done by providing additional implementations as a new OS is added. This guide will walk through the critical files in this layer to enable developer understanding and give an overview for individuals seeking to port to a new OS.</p>
<p>This guide discusses the following:</p><ul>
<li><a href="#tasks">Tasks</a></li>
<li><a href="#task-registry">Task Registry</a></li>
<li><a href="#mutexes">Mutexes</a></li>
<li><a href="#message-queues">Message Queues</a></li>
<li><a href="#interval-timer">Interval Timer</a></li>
<li><a href="#watchdog-timer">Watchdog Timer</a></li>
<li><a href="#interrupt-lock">Interrupt Lock</a></li>
<li><a href="#file">File</a></li>
<li><a href="#file-system">FileSystem</a></li>
<li><a href="#log">Log</a></li>
</ul>
<p>Tasks are called threads under Unix variants, and tasks under other OSes. A developer may wish to start tasks to wait on an event or a resource that is not a port invocation. The <a class="el" href="namespace_os.html">Os</a> task class definition can be found in <b>Os/OsTask.hpp</b>. The OS implementations are found in various subdirectories. Active components require use of tasks to implement their features. Table 23 describes the methods of the class.</p>
<p><b>Table 23.</b> Task method descriptions.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Description </th><th></th></tr>
<tr>
<td>start() </td><td>Starts the task. The arguments are: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>name </td><td>String name of the task. </td></tr>
<tr>
<td></td><td>identifier </td><td>A user-selected unique integer identifying the task. </td></tr>
<tr>
<td></td><td>priority </td><td>The priority of the task: 0 is lowest, 255 is highest. </td></tr>
<tr>
<td></td><td>stackSize </td><td>The size of the stack, in bytes. </td></tr>
<tr>
<td></td><td>routine </td><td>The function that will be called in the new task context. </td></tr>
<tr>
<td></td><td>arg </td><td>An argument passed to the thread. The arg argument to the routine will be set to this value. </td></tr>
<tr>
<td></td><td>cpuAffinity </td><td>In SMP systems, specify a processor core to run task. A value of -1 means no preference. </td></tr>
<tr>
<td>getIdentifier() </td><td>Returns the task identifier passed in the start() function. Useful when you have a collection of tasks to iterate over. </td><td></td></tr>
<tr>
<td>getOsIdentifier() </td><td>Gets the <a class="el" href="namespace_os.html">Os</a> Task ID. Useful for passive components. </td><td></td></tr>
<tr>
<td>getRawHandle() </td><td>Returns the task-handle owned by this task </td><td></td></tr>
<tr>
<td>delay() </td><td>Suspends execution of the task for the specified number of milliseconds. </td><td></td></tr>
<tr>
<td>getNumTasks() </td><td>Returns the number of active tasks in the system. </td><td></td></tr>
<tr>
<td>suspend() </td><td>Suspends the execution of the task. Not available on all operating systems. </td><td></td></tr>
<tr>
<td>resume() </td><td>Resumes execution of the task after a suspend() was issued. Not available on all operating systems. </td><td></td></tr>
<tr>
<td>wasSuspended() </td><td>Returns a Boolean to indicated whether or not the task was suspended via the suspend() call, or if it was suspended due to some other issue such as an exception. </td><td></td></tr>
<tr>
<td>isSuspended() </td><td>Check to see if the task is currently suspended. </td><td></td></tr>
<tr>
<td>setStarted() </td><td>Tells the task object that the task routine was called. Should be called from the routine registered in the start() call. </td><td></td></tr>
<tr>
<td>isStarted() </td><td>Returns true if the task routine was started successfully. Set by setStarted(). </td><td></td></tr>
<tr>
<td>registerTaskRegistry() </td><td>Allows a task registry to be passed for registering the task. This is a static call that should be called only once to register a singleton. </td><td></td></tr>
</table>
<p>Task registries are meant to be used to track all task instances in the system. The concept is that this registry would contain pointers to all the instances and be able to iterate over them and perform actions. The file <b>Os/Task/Task.hpp</b> provides a base class definition of a registry with the addTask() and removeTask() pure virtual function definitions. Developers would write their own derived classes to implement a registry that is appropriate for their system.</p>
<p>The class definition can be found in <b><a class="el" href="_mutex_8hpp.html">Os/Mutex.hpp</a></b>. The functions lock() and unlock() lock and unlock the mutex. The mutex should be unlocked after construction is complete.</p>
<p>The class definition can be found in <b><a class="el" href="_queue_8hpp.html">Os/Queue.hpp</a></b>. This class implements message queues. Table 24 describes the methods.</p>
<p><b>Table 24.</b> Message queues method descriptions.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Description </th><th></th></tr>
<tr>
<td>create() </td><td>Creates the message queue. The arguments are as follows: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>name </td><td>A string identifying the queue. If the OS supports it, it will be used to name the queue. </td></tr>
<tr>
<td></td><td>depth </td><td>The number of messages that a queue will support before dropping messages. </td></tr>
<tr>
<td></td><td>msgSize </td><td>Maximum size of a message. </td></tr>
<tr>
<td></td><td>block </td><td>A flag to indicate whether or not message receive calls should block. </td></tr>
<tr>
<td>send() </td><td>Send a message on the queue. The arguments are as follows: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>buffer </td><td>Buffer to send. This version of the function takes a reference to a SerializeBufferBase instance. This is used by the framework to send serialized port calls. </td></tr>
<tr>
<td></td><td>priority </td><td>The priority of the message. </td></tr>
<tr>
<td>send() </td><td>Send a message on the queue. The arguments are as follows: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>buffer </td><td>Buffer to send. This version of the function takes a pointer to a byte buffer. </td></tr>
<tr>
<td></td><td>priority </td><td>The priority of the message. Depending on the underlying OS implementation, the messages are received in priority order. </td></tr>
<tr>
<td>receive() </td><td>Receive a message from the queue. The arguments are as follows: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>buffer </td><td>Serialized buffer to put received message in. This version of the function takes a reference to a SerializeBufferBase instance. This is used by the framework to receive serialized port calls. </td></tr>
<tr>
<td></td><td>priority </td><td>The priority of the received message. </td></tr>
<tr>
<td>receive() </td><td>Receive a message from the queue. The arguments are as follows: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>buffer </td><td>Byte buffer to put received message in. This version of the function takes a pointer to a byte buffer. </td></tr>
<tr>
<td></td><td>capacity </td><td>The capacity of the receiving buffer. If it is not large enough for the message, the message will not be written and the function will return with an error. </td></tr>
<tr>
<td></td><td>actualSize </td><td>The size of the received message. Will not exceed capacity. </td></tr>
<tr>
<td></td><td>priority </td><td>The priority of the received message. </td></tr>
<tr>
<td>getNumQueues </td><td>Returns the number of message queues created in the system. </td><td></td></tr>
</table>
<p>The class definition can be found in <a class="el" href="_interval_timer_8hpp.html">Os/IntervalTimer.hpp</a>. An interval timer is a facility that starts and stops the measurement of passage of time in the system. It is not an expiration timer that signals when it is complete. It is used to measure execution times of, or to timestamp, software activities. Table 25 provides the methods and their descriptions.</p>
<p><b>Table 25.</b> Interval timer method descriptions.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Description  </th></tr>
<tr>
<td>start() </td><td>Saves the start time of the timer. </td></tr>
<tr>
<td>stop() </td><td>Saves the stop time of the timer. </td></tr>
<tr>
<td>getDiffUsec() </td><td>Returns the time difference between start and stop in microseconds. </td></tr>
<tr>
<td>getDiffUsec() </td><td>Overloaded version that takes two times, subtracts them, and returns the difference in microseconds. </td></tr>
<tr>
<td>getRawTime() </td><td>Gets the current raw time value. Can be used for time-tagging events. </td></tr>
</table>
<p><b>Note:</b> this file implementation is not required for all OS adaptations. Only those needing watchdog functionality.</p>
<p>The class definition can be found in <b><a class="el" href="_watchdog_timer_8hpp.html">Os/WatchdogTimer.hpp</a></b> A watchdog timer schedules a callback at the specified time in the future. It is a one-shot timer; it needs to be rescheduled each time. Table 26 provides the methods and their descriptions.</p>
<p><b>Table 26.</b> Watchdog timer method descriptions.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Description </th><th></th></tr>
<tr>
<td>startTicks </td><td>Starts the timer and gives the expiration in units of system ticks. The arguments are: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>delayInTicks </td><td>Ticks to delay. OS/platform specific. </td></tr>
<tr>
<td></td><td>p_callback </td><td>Function to call when timer expires. </td></tr>
<tr>
<td></td><td>parameter </td><td>Value passed to callback </td></tr>
<tr>
<td>startMs </td><td>Starts the timer and gives the expiration in units of milliseconds. The arguments are: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>delayInMs </td><td>Milliseconds to delay. Could be rounded up to the next system timer interval in ticks. </td></tr>
<tr>
<td></td><td>p_callback </td><td>Function to call when timer expires. </td></tr>
<tr>
<td></td><td>parameter </td><td>Value passed to callback </td></tr>
<tr>
<td>restart() </td><td>Restart the timer using the value passed to startTicks() or startMs(). If a different expiration time is desired, the start functions should be called instead. </td><td></td></tr>
<tr>
<td>cancel() </td><td>Cancel the timer in progress. The callback will not be called. </td><td></td></tr>
</table>
<p>The class definition can be found in <a class="el" href="_interrupt_lock_8hpp.html">Os/InterruptLock.hpp</a>*.* An interrupt lock prevents interrupts from preempting code execution. It can be used as a very lightweight mutex on platforms that support interrupt locking, but should be used carefully as it is not subject to priorities like a conventional mutex. In addition, it defers interrupts that could be time critical, so the code executed between the locking and unlocking should be very short in duration. This is a portable interface, but the user should be aware of the behavior for each OS. Table 27 provides the methods and their descriptions.</p>
<p><b>Table 27.</b> Interrupt lock method descriptions.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Description  </th></tr>
<tr>
<td>lock() </td><td>Lock interrupts. </td></tr>
<tr>
<td>unlock() </td><td>Unlock interrupts. </td></tr>
<tr>
<td>getKey() </td><td>Returns the interrupt lock key, if used by the OS. This is typically not needed. </td></tr>
</table>
<p>The class definition can be found in <a class="el" href="_file_8hpp.html">Os/File.hpp</a>*.* The file class attempts to abstract the most common file functions to a class interface to make porting code that does file accesses easier. Table 28 provides the methods and their descriptions.</p>
<p><b>Table 28.</b> File method descriptions.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Description </th><th></th></tr>
<tr>
<td>open() </td><td>Open the file with the given filename and mode. </td><td></td></tr>
<tr>
<td>isOpen() </td><td>Detect if the file is open </td><td></td></tr>
<tr>
<td>seek() </td><td>Move the current location of the file to the offset. If absolute = true, move it relative to the beginning of the file, otherwise relative to the current location. </td><td></td></tr>
<tr>
<td>read() </td><td>Reads data from the file into a buffer. The arguments are as follows: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>buffer </td><td>Destination buffer for data. </td></tr>
<tr>
<td></td><td>size </td><td>Size to read. When read is complete, size is modified to actual size. </td></tr>
<tr>
<td></td><td>waitForFull </td><td>If true, wait until full size is read, continuing reads when signals are encountered. If end-of-file is encountered, will return with less than full amount requested. </td></tr>
<tr>
<td>write() </td><td>Writes data to the file from a buffer. The arguments are as follows: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>buffer </td><td>Source buffer for data. </td></tr>
<tr>
<td></td><td>size </td><td>Size to write. When write is complete, size is modified to actual size. </td></tr>
<tr>
<td></td><td>waitForDone </td><td>If true, wait until full size is written, continuing writes when signals are encountered. </td></tr>
<tr>
<td>flush() </td><td>Flush data to disk. No-op on systems that do not support. </td><td></td></tr>
<tr>
<td>close() </td><td>Close the file. The file is automatically called by the destructor, but this method provides a way to manually close it as well. </td><td></td></tr>
<tr>
<td>getLastError() </td><td>Returns the last error value. Meant to abstract errno. </td><td></td></tr>
<tr>
<td>getLastErrorString() </td><td>Returns a text description of the error for the last file operation. Meant to abstract strerror(). </td><td></td></tr>
<tr>
<td>calculateCRC32() </td><td>Calculates the CRC32 of the file </td><td></td></tr>
</table>
<p>The file system OS classes found in <b><a class="el" href="_file_system_8hpp.html">Os/FileSystem.hpp</a></b> contains the file system helper calls to create directories remove directories etc.</p>
<p><b>Note:</b> there is also the <b><a class="el" href="_directory_8hpp.html">Os/Directory.hpp</a></b> classes that allows users to stream directories.</p>
<p>This class definition can be found in <b><a class="el" href="_log_8hpp.html">Os/Log.hpp</a></b>. It is an interface to a system logging facility. It is meant to abstract the VxWorks logging facility. It is a subclass of <code><a class="el" href="class_fw_1_1_logger.html">Fw::Logger</a></code> and thus must be registered after construction. Compiling in <b><a class="el" href="_log_default_8cpp.html">Os/LogDefault.cpp</a></b> into your deployment will automatically create an <b><a class="el" href="class_os_1_1_log.html">Os::Log</a></b> and register it. Table 30 provides the methods and their descriptions.</p>
<p><b>Table 30.</b> Log method descriptions.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Description </th><th></th></tr>
<tr>
<td>logMsg </td><td>Log a text message. The arguments are: </td><td></td></tr>
<tr>
<td></td><td><b>Argument</b> </td><td><b>Description</b> </td></tr>
<tr>
<td></td><td>fmt </td><td>Format string to fill and print. </td></tr>
<tr>
<td></td><td>a1 to a6 </td><td>Values to be printed. They will be inserted into the format string based on the format string specifiers. The type of the argument is POINTER_CAST (normally an integer), but a typical usage is to cast the values to display to POINTER_CAST and allow the format string extraction to get the correct value. This can include strings (char*), but the location in memory that holds the string must persist since the format string may be printed on another task in the system. </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
